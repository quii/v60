// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package v60

import (
	"sync"
	"time"
)

// Ensure, that StopwatchMock does implement Stopwatch.
// If this is not the case, regenerate this file with moq.
var _ Stopwatch = &StopwatchMock{}

// StopwatchMock is a mock implementation of Stopwatch.
//
//     func TestSomethingThatUsesStopwatch(t *testing.T) {
//
//         // make and configure a mocked Stopwatch
//         mockedStopwatch := &StopwatchMock{
//             WaitFunc: func(duration time.Duration)  {
// 	               panic("mock out the Wait method")
//             },
//         }
//
//         // use mockedStopwatch in code that requires Stopwatch
//         // and then make assertions.
//
//     }
type StopwatchMock struct {
	// WaitFunc mocks the Wait method.
	WaitFunc func(duration time.Duration)

	// calls tracks calls to the methods.
	calls struct {
		// Wait holds details about calls to the Wait method.
		Wait []struct {
			// Duration is the duration argument value.
			Duration time.Duration
		}
	}
	lockWait sync.RWMutex
}

// Wait calls WaitFunc.
func (mock *StopwatchMock) Wait(duration time.Duration) {
	if mock.WaitFunc == nil {
		panic("StopwatchMock.WaitFunc: method is nil but Stopwatch.Wait was just called")
	}
	callInfo := struct {
		Duration time.Duration
	}{
		Duration: duration,
	}
	mock.lockWait.Lock()
	mock.calls.Wait = append(mock.calls.Wait, callInfo)
	mock.lockWait.Unlock()
	mock.WaitFunc(duration)
}

// WaitCalls gets all the calls that were made to Wait.
// Check the length with:
//     len(mockedStopwatch.WaitCalls())
func (mock *StopwatchMock) WaitCalls() []struct {
	Duration time.Duration
} {
	var calls []struct {
		Duration time.Duration
	}
	mock.lockWait.RLock()
	calls = mock.calls.Wait
	mock.lockWait.RUnlock()
	return calls
}
